<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 4: Requirements & System Models</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .content {
            padding: 40px;
        }

        .section {
            margin-bottom: 50px;
            padding: 30px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 5px solid #667eea;
        }

        .section h2 {
            color: #667eea;
            font-size: 2em;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }

        .section h3 {
            color: #764ba2;
            font-size: 1.5em;
            margin-top: 25px;
            margin-bottom: 15px;
        }

        .section p {
            margin-bottom: 15px;
            text-align: justify;
        }

        .visualization {
            background: white;
            padding: 30px;
            margin: 25px 0;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .diagram {
            width: 100%;
            min-height: 300px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            background: #fff;
        }

        .box {
            display: inline-block;
            padding: 15px 25px;
            margin: 10px;
            border: 2px solid #667eea;
            border-radius: 8px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: bold;
            text-align: center;
            min-width: 150px;
        }

        .arrow {
            display: inline-block;
            font-size: 2em;
            color: #667eea;
            margin: 0 10px;
        }

        .process-flow {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin: 20px 0;
        }

        .model-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .model-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #667eea;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .model-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 12px rgba(0,0,0,0.2);
        }

        .model-card h4 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 1.3em;
        }

        .example {
            background: #e8eaf6;
            padding: 20px;
            border-left: 4px solid #667eea;
            margin: 20px 0;
            border-radius: 5px;
        }

        .example-title {
            font-weight: bold;
            color: #667eea;
            margin-bottom: 10px;
        }

        .highlight {
            background: #fff3cd;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: bold;
        }

        .interactive-section {
            background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: bold;
        }

        tr:hover {
            background: #f5f5f5;
        }

        .context-diagram {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            padding: 30px;
        }

        .system-center {
            width: 200px;
            height: 200px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            font-size: 1.2em;
            margin: 20px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
        }

        .external-entity {
            width: 120px;
            height: 80px;
            background: #f0f0f0;
            border: 2px solid #667eea;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 10px;
            font-size: 0.9em;
        }

        .uml-class {
            border: 2px solid #667eea;
            border-radius: 8px;
            overflow: hidden;
            background: white;
            margin: 20px auto;
            max-width: 400px;
        }

        .uml-class-name {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            text-align: center;
            font-weight: bold;
            font-size: 1.2em;
        }

        .uml-attributes, .uml-methods {
            padding: 15px;
            border-top: 2px solid #667eea;
        }

        .uml-item {
            padding: 5px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
            }

            header h1 {
                font-size: 1.8em;
            }

            .content {
                padding: 20px;
            }

            .section {
                padding: 20px;
            }

            .model-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>MODULE 4</h1>
            <p>Requirements Validation, Requirements Management & System Models</p>
        </header>

        <div class="content">
            <!-- Requirements Validation Section -->
            <div class="section">
                <h2>üîç Requirements Validation</h2>
                
                <p>Requirements validation is a critical process in software engineering that ensures the documented requirements actually reflect what the stakeholders need and what the system should do. Think of it as a quality check before you start building‚Äîit's much easier to fix a blueprint than to rebuild a house. The validation process asks fundamental questions: Are these requirements what the users really need? Can they actually be implemented? Are they complete and consistent?</p>

                <div class="visualization">
                    <h3>Why Requirements Validation Matters</h3>
                    <p>Catching errors in requirements is exponentially cheaper than fixing them later. A defect found during requirements costs about $1 to fix, but if that same defect makes it to the design phase, it costs $5, to implementation it costs $10, and if it reaches production, it can cost $100 or more. This dramatic increase happens because each subsequent phase builds upon the previous one, creating a cascading effect of changes.</p>
                    
                    <div class="example">
                        <div class="example-title">Real-World Example:</div>
                        Imagine a banking application where the requirement states "The system shall process transactions quickly." During validation, you discover that "quickly" means different things to different stakeholders‚Äîcustomers expect under 2 seconds, while the technical team thought 10 seconds was acceptable. Without validation, you might build a system that satisfies the technical team but frustrates users.
                    </div>
                </div>

                <div class="visualization">
                    <h3>Key Validation Techniques</h3>
                    
                    <div class="model-grid">
                        <div class="model-card">
                            <h4>Requirements Reviews</h4>
                            <p>A team of reviewers systematically examines the requirements document, looking for errors, ambiguities, and omissions. This is like having multiple pairs of eyes proofread an important document‚Äîeach person brings their unique perspective and catches different issues.</p>
                        </div>

                        <div class="model-card">
                            <h4>Prototyping</h4>
                            <p>Building a working model of the system helps stakeholders visualize what they're asking for. Often, seeing a prototype reveals requirements that were missed or misunderstood. It's the software equivalent of a test drive before buying a car.</p>
                        </div>

                        <div class="model-card">
                            <h4>Test-Case Generation</h4>
                            <p>Writing test cases from requirements forces you to think through how the system will actually be used. If you can't write a clear test case for a requirement, that requirement is probably too vague or poorly specified.</p>
                        </div>

                        <div class="model-card">
                            <h4>Consistency Analysis</h4>
                            <p>Using automated tools to check that requirements don't contradict each other. For instance, one requirement might say "all users must be authenticated" while another says "guest users can browse the catalog"‚Äîthese need to be reconciled.</p>
                        </div>
                    </div>
                </div>

                <div class="visualization">
                    <h3>The Validation Process Flow</h3>
                    <div class="diagram">
                        <div class="process-flow">
                            <div class="box">Gather Requirements</div>
                            <span class="arrow">‚Üí</span>
                            <div class="box">Review for Completeness</div>
                            <span class="arrow">‚Üí</span>
                            <div class="box">Check Consistency</div>
                            <span class="arrow">‚Üí</span>
                            <div class="box">Verify Feasibility</div>
                            <span class="arrow">‚Üí</span>
                            <div class="box">Stakeholder Approval</div>
                        </div>
                    </div>
                    <p>Each step in this flow acts as a filter, catching different types of problems. Completeness checks ensure nothing is missing, consistency checks prevent contradictions, feasibility checks ensure the requirements can actually be built with available resources, and stakeholder approval confirms everyone agrees on what's being built.</p>
                </div>

                <div class="interactive-section">
                    <h3>Validation Checklist</h3>
                    <table>
                        <thead>
                            <tr>
                                <th>Check Type</th>
                                <th>What It Verifies</th>
                                <th>Example Question</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Validity</strong></td>
                                <td>Does the system provide functions supporting user needs?</td>
                                <td>"Will this feature actually help users complete their tasks?"</td>
                            </tr>
                            <tr>
                                <td><strong>Consistency</strong></td>
                                <td>Are there conflicting requirements?</td>
                                <td>"Do any requirements contradict each other?"</td>
                            </tr>
                            <tr>
                                <td><strong>Completeness</strong></td>
                                <td>Are all functions the users need included?</td>
                                <td>"Have we covered all the user scenarios?"</td>
                            </tr>
                            <tr>
                                <td><strong>Realism</strong></td>
                                <td>Can requirements be implemented with available budget and technology?</td>
                                <td>"Can we actually build this with our resources?"</td>
                            </tr>
                            <tr>
                                <td><strong>Verifiability</strong></td>
                                <td>Can we write tests to check if requirements are met?</td>
                                <td>"How will we know when this requirement is satisfied?"</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Requirements Management Section -->
            <div class="section">
                <h2>üìã Requirements Management</h2>
                
                <p>Requirements management is the ongoing process of handling changes to requirements throughout the project lifecycle. Unlike validation, which happens at a specific point, management is continuous. Requirements rarely stay frozen‚Äîbusiness needs evolve, technology changes, regulations update, and stakeholders gain new insights. Good requirements management ensures that changes are controlled, tracked, and communicated effectively so the project doesn't descend into chaos.</p>

                <div class="visualization">
                    <h3>Why Requirements Change</h3>
                    <p>Understanding why requirements change helps us manage them better. Changes typically fall into several categories:</p>
                    
                    <div class="model-grid">
                        <div class="model-card">
                            <h4>Business Evolution</h4>
                            <p>The business environment changes‚Äînew competitors emerge, market conditions shift, or company strategy pivots. A retail system might need mobile payment features added because competitors launched them.</p>
                        </div>

                        <div class="model-card">
                            <h4>Better Understanding</h4>
                            <p>As stakeholders see prototypes and early versions, they understand their needs better. What seemed clear on paper becomes fuzzy when implemented, leading to refinement requests.</p>
                        </div>

                        <div class="model-card">
                            <h4>Technical Discoveries</h4>
                            <p>During development, teams discover that some requirements are harder or easier than expected, leading to scope adjustments. Perhaps the chosen database can't handle the required transaction volume.</p>
                        </div>

                        <div class="model-card">
                            <h4>External Factors</h4>
                            <p>New regulations, security threats, or technology changes force requirement updates. GDPR compliance wasn't a requirement until the regulation passed, then it became mandatory for many systems.</p>
                        </div>
                    </div>
                </div>

                <div class="visualization">
                    <h3>Requirements Management Process</h3>
                    <div class="diagram">
                        <div class="process-flow">
                            <div class="box">Change Request</div>
                            <span class="arrow">‚Üí</span>
                            <div class="box">Impact Analysis</div>
                            <span class="arrow">‚Üí</span>
                            <div class="box">Change Approval</div>
                            <span class="arrow">‚Üí</span>
                            <div class="box">Update Requirements</div>
                            <span class="arrow">‚Üí</span>
                            <div class="box">Notify Stakeholders</div>
                        </div>
                    </div>
                    
                    <p>Each change goes through this controlled process. When someone requests a change, the team analyzes its impact‚Äîhow many other requirements does it affect? How much will it cost in time and money? Will it delay the project? Only after understanding the full implications and getting proper approval are requirements updated, and then all affected parties are informed.</p>

                    <div class="example">
                        <div class="example-title">Practical Scenario:</div>
                        A client requests adding two-factor authentication to a nearly complete e-commerce site. Impact analysis reveals this affects login flows, database schema, user interface, testing, and documentation. The change needs security team approval, adds three weeks to the schedule, and requires updating twenty related requirements. Management helps track all these interconnected changes.
                    </div>
                </div>

                <div class="interactive-section">
                    <h3>Key Management Activities</h3>
                    
                    <div class="model-card" style="margin: 20px 0;">
                        <h4>Requirements Traceability</h4>
                        <p>Creating and maintaining links between requirements and other project artifacts. If a requirement changes, traceability shows exactly which design documents, code modules, and test cases are affected. It's like having a map that shows how everything connects‚Äîwhen you need to reroute one road, you can see which neighborhoods it impacts.</p>
                    </div>

                    <div class="model-card" style="margin: 20px 0;">
                        <h4>Version Control</h4>
                        <p>Maintaining a history of requirements changes with timestamps and rationales. This creates an audit trail showing what changed, when, why, and who approved it. It's invaluable when questions arise months later about why certain decisions were made.</p>
                    </div>

                    <div class="model-card" style="margin: 20px 0;">
                        <h4>Change Impact Assessment</h4>
                        <p>Systematically evaluating how a proposed change ripples through the system. This prevents the common problem of accepting a "small change" that turns out to require massive rework across multiple components.</p>
                    </div>

                    <div class="model-card" style="margin: 20px 0;">
                        <h4>Requirements Prioritization</h4>
                        <p>Continuously ranking requirements by importance, helping teams make informed decisions when trade-offs are necessary. Using techniques like MoSCoW (Must have, Should have, Could have, Won't have) helps stakeholders understand what's essential versus nice-to-have.</p>
                    </div>
                </div>
            </div>

            <!-- System Models Section -->
            <div class="section">
                <h2>üèóÔ∏è System Models</h2>
                
                <p>System models are abstract representations of a system that help us understand, communicate, and analyze different aspects of what we're building. Just as architects use blueprints to show different views of a building (floor plans, elevations, electrical layouts), software engineers use different models to show different perspectives of a software system. Each model type reveals certain aspects while deliberately hiding others to avoid overwhelming complexity.</p>

                <!-- Context Models -->
                <div class="visualization">
                    <h3>1. Context Models</h3>
                    <p>Context models show the system and its environment, defining the boundary between what we're building and what already exists. They answer the fundamental question: "What is inside our system and what is outside?" This helps establish scope and identify external dependencies. Context models are typically the first models created because they establish the playing field for all other models.</p>

                    <div class="context-diagram">
                        <h4 style="text-align: center; margin-bottom: 20px;">Context Diagram Example: Library Management System</h4>
                        
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; width: 100%; max-width: 600px; margin-bottom: 30px;">
                            <div style="grid-column: 2;">
                                <div class="external-entity">Librarian</div>
                            </div>
                        </div>

                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; width: 100%; max-width: 600px;">
                            <div class="external-entity">Library Member</div>
                            <div class="system-center">Library Management System</div>
                            <div class="external-entity">Book Supplier</div>
                        </div>

                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; width: 100%; max-width: 600px; margin-top: 30px;">
                            <div style="grid-column: 2;">
                                <div class="external-entity">Payment Gateway</div>
                            </div>
                        </div>
                    </div>

                    <div class="example">
                        <div class="example-title">Understanding the Context:</div>
                        In this library system context model, the central circle represents our system. The external entities (Librarian, Library Member, Book Supplier, Payment Gateway) are outside our control but interact with our system. The Librarian manages books and members, Members borrow and return books, Suppliers provide new inventory, and the Payment Gateway handles fines. This model immediately shows us what interfaces we need to build and what external systems we need to integrate with.
                    </div>

                    <p style="margin-top: 20px;">Context models help prevent scope creep by clearly showing what's in and out of scope. They also help identify risks‚Äîif your system depends on an external payment gateway, you need to plan for what happens when that gateway is down. These models are invaluable for communicating with non-technical stakeholders because they're simple and intuitive.</p>
                </div>

                <!-- Behavioral Models -->
                <div class="visualization">
                    <h3>2. Behavioral Models</h3>
                    <p>Behavioral models describe how the system responds to external events and how it behaves over time. They show the dynamic aspects of the system‚Äîwhat happens when a user clicks a button, how the system reacts to errors, or how different components interact during execution. While context models show structure, behavioral models show action and change.</p>

                    <div class="interactive-section">
                        <h4>Common Behavioral Model Types:</h4>
                        
                        <div class="model-card" style="margin: 20px 0;">
                            <h4>State Machine Diagrams</h4>
                            <p>These show how an object or system transitions between different states in response to events. Consider an order in an e-commerce system‚Äîit starts in a "Pending" state, moves to "Paid" when payment is confirmed, transitions to "Shipped" when dispatched, and finally reaches "Delivered." Each transition happens because of a specific event (payment received, shipping confirmed, delivery completed).</p>
                            
                            <div class="diagram">
                                <div class="process-flow">
                                    <div class="box">New Order</div>
                                    <span class="arrow">‚Üí</span>
                                    <div class="box">Payment Pending</div>
                                    <span class="arrow">‚Üí</span>
                                    <div class="box">Processing</div>
                                    <span class="arrow">‚Üí</span>
                                    <div class="box">Shipped</div>
                                    <span class="arrow">‚Üí</span>
                                    <div class="box">Delivered</div>
                                </div>
                            </div>
                        </div>

                        <div class="model-card" style="margin: 20px 0;">
                            <h4>Sequence Diagrams</h4>
                            <p>These show how objects interact in a particular scenario, emphasizing the time-ordered sequence of messages. Imagine a user logging into a system: the browser sends credentials to the web server, the web server queries the database to verify credentials, the database returns the result, the web server creates a session, and finally sends a response to the browser. Sequence diagrams make this temporal flow explicit.</p>
                        </div>

                        <div class="model-card" style="margin: 20px 0;">
                            <h4>Activity Diagrams</h4>
                            <p>These model workflows and business processes, showing the flow of control from activity to activity. They're particularly useful for modeling complex business processes with decision points and parallel activities. For instance, a hiring process might include parallel activities like background checks and reference calls, with decision points like "Did candidate pass screening?"</p>
                        </div>
                    </div>

                    <div class="example">
                        <div class="example-title">When to Use Behavioral Models:</div>
                        Behavioral models are essential when you need to understand or communicate how the system responds to inputs. They're particularly valuable for identifying edge cases and error conditions. For example, modeling the behavior of an ATM machine helps you think through questions like: "What happens if the network fails mid-transaction?" or "What if the user cancels after PIN entry but before amount selection?"
                    </div>
                </div>

                <!-- Data Models -->
                <div class="visualization">
                    <h3>3. Data Models</h3>
                    <p>Data models describe the structure and organization of data that the system uses and creates. They show what information needs to be stored, how different pieces of information relate to each other, and what constraints and rules apply to the data. While behavioral models show what the system does, data models show what the system knows.</p>

                    <div class="interactive-section">
                        <h4>Understanding Data Relationships</h4>
                        <p>The most common data modeling technique is Entity-Relationship (ER) modeling. Entities are things we need to store information about (like Customer, Order, Product), and relationships describe how entities connect (a Customer places Orders, an Order contains Products). Understanding these relationships is crucial for database design and ensuring data integrity.</p>

                        <table>
                            <thead>
                                <tr>
                                    <th>Relationship Type</th>
                                    <th>Description</th>
                                    <th>Example</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>One-to-One</strong></td>
                                    <td>Each entity in A relates to exactly one entity in B</td>
                                    <td>A person has one passport; a passport belongs to one person</td>
                                </tr>
                                <tr>
                                    <td><strong>One-to-Many</strong></td>
                                    <td>One entity in A relates to multiple entities in B</td>
                                    <td>A customer places many orders; an order belongs to one customer</td>
                                </tr>
                                <tr>
                                    <td><strong>Many-to-Many</strong></td>
                                    <td>Multiple entities in A relate to multiple entities in B</td>
                                    <td>Students enroll in many courses; courses have many students</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <div class="example">
                        <div class="example-title">Data Model Example: University System</div>
                        <p>Consider a university system that needs to track students, courses, professors, and enrollments. The data model would show that Students enroll in Courses (many-to-many relationship), Professors teach Courses (one-to-many, assuming a course has one instructor), and Courses belong to Departments (many-to-one). The model would also specify attributes like Student ID, Name, GPA for students, and Course Code, Title, Credits for courses. Constraints might include "GPA must be between 0.0 and 4.0" or "Course Code must be unique."</p>
                    </div>

                    <p style="margin-top: 20px;">Data models are fundamental because they directly influence database schema design. A well-designed data model prevents data redundancy, maintains consistency, and ensures efficient querying. Poor data models lead to performance problems and data integrity issues that are expensive to fix later. They're also crucial for ensuring the system can evolve‚Äîa flexible data model makes it easier to add new features without restructuring the entire database.</p>
                </div>

                <!-- Object Models -->
                <div class="visualization">
                    <h3>4. Object Models</h3>
                    <p>Object models show the system structure in terms of objects and classes, which are the fundamental building blocks in object-oriented systems. While data models focus on what information to store, object models combine data with the operations that work on that data, showing both the structure and behavior of system components. This is the bridge between what the system knows (data) and what it does (behavior).</p>

                    <div class="uml-class">
                        <div class="uml-class-name">BankAccount</div>
                        <div class="uml-attributes">
                            <div class="uml-item">- accountNumber: String</div>
                            <div class="uml-item">- balance: Double</div>
                            <div class="uml-item">- accountHolder: String</div>
                            <div class="uml-item">- accountType: String</div>
                        </div>
                        <div class="uml-methods">
                            <div class="uml-item">+ deposit(amount: Double): Boolean</div>
                            <div class="uml-item">+ withdraw(amount: Double): Boolean</div>
                            <div class="uml-item">+ getBalance(): Double</div>
                            <div class="uml-item">+ transfer(amount: Double, toAccount: BankAccount): Boolean</div>
                        </div>
                    </div>

                    <p style="text-align: center; margin-top: 10px; font-size: 0.9em; color: #666;">UML Class Diagram showing attributes (data) and methods (operations)</p>

                    <div class="interactive-section" style="margin-top: 30px;">
                        <h4>Key Object-Oriented Concepts</h4>
                        
                        <div class="model-card" style="margin: 20px 0;">
                            <h4>Encapsulation</h4>
                            <p>Bundling data and methods that operate on that data within a single unit (class). Notice in the BankAccount example how the balance is private (marked with -) and can only be changed through public methods (marked with +) like deposit() and withdraw(). This protects data integrity‚Äîyou can't accidentally set a negative balance by directly accessing the balance variable.</p>
                        </div>

                        <div class="model-card" style="margin: 20px 0;">
                            <h4>Inheritance</h4>
                            <p>Creating new classes based on existing ones, inheriting their attributes and methods. For example, you might have a general Vehicle class with properties like speed and color, and then create specific Car and Motorcycle classes that inherit these properties but add their own unique features (Car has numberOfDoors, Motorcycle has engineSize).</p>
                        </div>

                        <div class="model-card" style="margin: 20px 0;">
                            <h4>Polymorphism</h4>
                            <p>The ability of different objects to respond to the same message in different ways. If you have a draw() method, a Circle object and a Rectangle object might both implement it, but they draw themselves differently. This allows you to write code that works with any shape without knowing the specific type.</p>
                        </div>

                        <div class="model-card" style="margin: 20px 0;">
                            <h4>Association</h4>
                            <p>Relationships between classes. A Student enrolls in Courses, a Library has Books, an Order contains Products. Object models show these connections explicitly, including their multiplicity (one-to-one, one-to-many, etc.) and directionality (can you navigate from Order to Customer? From Customer to Orders?).</p>
                        </div>
                    </div>

                    <div class="example">
                        <div class="example-title">Object Modeling in Practice:</div>
                        When designing a social media platform, object modeling helps you think through questions like: What are the main entities? (User, Post, Comment, Like). What properties do they have? (User has username, email, profilePicture; Post has content, timestamp, author). What can they do? (User can createPost(), Comment.delete(), Post.addLike()). How do they relate? (User creates Posts, Posts have Comments, Users like Posts). This systematic thinking prevents critical oversights and creates a solid foundation for implementation.
                    </div>
                </div>

                <!-- Structured Methods -->
                <div class="visualization">
                    <h3>5. Structured Methods</h3>
                    <p>Structured methods are systematic approaches to developing system models that provide step-by-step guidance on how to analyze, design, and document systems. They emerged in the 1970s-80s as a way to bring engineering discipline to software development. While object-oriented approaches are now dominant, understanding structured methods provides valuable insights into how to think systematically about complex systems.</p>

                    <div class="interactive-section">
                        <h4>Core Principles of Structured Methods</h4>
                        
                        <div class="model-card" style="margin: 20px 0;">
                            <h4>Top-Down Decomposition</h4>
                            <p>Breaking a complex system into smaller, manageable pieces. Start with the big picture, then progressively refine each piece into more detail. It's like writing an outline for a book‚Äîyou start with chapters, break chapters into sections, sections into subsections, until you reach individual paragraphs. In software, you might start with "Process Order," decompose it into "Validate Payment," "Update Inventory," and "Generate Confirmation," then further break down each of those.</p>
                        </div>

                        <div class="model-card" style="margin: 20px 0;">
                            <h4>Functional Decomposition</h4>
                            <p>Organizing the system based on what it does rather than what data it stores. A structured approach to an ATM might identify functions like "Verify PIN," "Check Balance," "Dispense Cash," "Print Receipt," and show how they relate and call each other. Each function is defined in terms of its inputs, outputs, and the transformation it performs.</p>
                        </div>

                        <div class="model-card" style="margin: 20px 0;">
                            <h4>Data Flow Diagrams (DFD)</h4>
                            <p>The primary tool in structured methods, DFDs show how data moves through the system. They use four simple symbols: circles for processes that transform data, rectangles for external entities that provide or receive data, arrows for data flows, and parallel lines for data stores. This simplicity makes them excellent communication tools with non-technical stakeholders.</p>
                        </div>

                        <div class="model-card" style="margin: 20px 0;">
                            <h4>Process Specifications</h4>
                            <p>Detailed descriptions of what each process does, written in structured English, decision tables, or decision trees. For example, the "Calculate Shipping Cost" process might be specified as: "IF weight > 50 pounds AND destination is international THEN apply heavy international rate, ELSE IF weight > 50 pounds THEN apply heavy domestic rate," and so on.</p>
                        </div>
                    </div>

                    <div class="diagram">
                        <h4 style="text-align: center; margin-bottom: 20px;">Structured Method Process Flow</h4>
                        <div class="process-flow">
                            <div class="box">Requirements Analysis</div>
                            <span class="arrow">‚Üì</span>
                            <div class="box">Create Context DFD</div>
                            <span class="arrow">‚Üì</span>
                            <div class="box">Decompose into Level 1 DFD</div>
                            <span class="arrow">‚Üì</span>
                            <div class="box">Further Decompose Complex Processes</div>
                            <span class="arrow">‚Üì</span>
                            <div class="box">Specify Process Logic</div>
                            <span class="arrow">‚Üì</span>
                            <div class="box">Define Data Dictionary</div>
                        </div>
                    </div>

                    <div class="example">
                        <div class="example-title">Structured Methods vs. Object-Oriented Methods:</div>
                        Structured methods focus on processes and data flows‚Äîwhat the system does and how information moves through it. Object-oriented methods focus on objects and their interactions‚Äîwhat things exist and how they relate. Neither is inherently better; they're different perspectives. Structured methods excel at modeling business processes and data-intensive systems. Object-oriented methods excel at modeling complex systems with rich behavior and systems that need to evolve over time. Many modern projects use both‚Äîstructured techniques for business analysis and process modeling, object-oriented techniques for system design and implementation.
                    </div>
                </div>
            </div>

            <!-- Synthesis Section -->
            <div class="section">
                <h2>üéØ Bringing It All Together</h2>
                
                <p>Understanding how these concepts interconnect is crucial for successful software engineering. Requirements validation and management ensure you're building the right thing and adapting to change. System models help you understand and communicate what you're building from multiple perspectives. Each model type reveals different aspects: context models show boundaries, behavioral models show dynamics, data models show structure, object models show implementation blueprints, and structured methods provide systematic approaches to analysis.</p>

                <div class="visualization">
                    <h3>The Development Flow</h3>
                    <div class="diagram" style="min-height: 200px;">
                        <div style="text-align: center; padding: 20px;">
                            <p style="margin-bottom: 20px;"><strong>Requirements</strong> (validated through reviews, prototyping, testing)</p>
                            <p style="font-size: 1.5em; color: #667eea;">‚Üì</p>
                            <p style="margin: 20px 0;"><strong>System Models</strong> (context, behavioral, data, object)</p>
                            <p style="font-size: 1.5em; color: #667eea;">‚Üì</p>
                            <p style="margin: 20px 0;"><strong>Design & Implementation</strong></p>
                            <p style="font-size: 1.5em; color: #667eea;">‚Üì</p>
                            <p style="margin-top: 20px;"><strong>Testing & Validation</strong></p>
                            <div style="margin-top: 20px; padding: 15px; background: #fff3cd; border-radius: 8px;">
                                <strong>Requirements Management</strong> operates continuously throughout, handling changes and maintaining traceability
                            </div>
                        </div>
                    </div>
                </div>

                <div class="example">
                    <div class="example-title">Final Thought:</div>
                    Software engineering is fundamentally about managing complexity. Requirements validation ensures you start with the right understanding. Requirements management ensures you adapt correctly as understanding evolves. System models break down complexity into manageable views, each showing what you need to see while hiding what you don't. Together, these practices transform the seemingly impossible task of building large, complex software systems into a structured, manageable process. The key is choosing the right models and techniques for your specific context‚Äînot every project needs every model type, but every project needs some systematic approach to managing complexity.
                </div>
            </div>
        </div>
    </div>
</body>
</html>